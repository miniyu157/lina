#!/system/bin/sh

# SPDX-License-Identifier: GPL-3.0-or-later
# Copyright (C) 2025 Yumeka <miniyu157@163.com>

# shellcheck shell=ksh
# shellcheck disable=SC2086

if [ "$(id -u)" -ne 0 ]; then
    current_script="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
    quoted_args=$(printf " %q" "$@")
    exec su -M -c "exec '$current_script'$quoted_args"
fi
ScriptDir="$(cd "$(dirname "$0")" && pwd)"

# 启用此段以使用 makepkg 风格输出
if [[ ! -f "$ScriptDir/lib/message.sh" ]]; then
    echo "错误: 未找到 $ScriptDir/lib/message.sh" >&2
    exit 1
fi
source "$ScriptDir/lib/message.sh"
QUIET=0
colorize

# 启用此行以使用其它自定义脚本
#PATH="$ScriptDir:$PATH"
# 启用以下两行以使用 Termux 中的二进制程序和库
export LD_LIBRARY_PATH="/data/data/com.termux/files/usr/lib"
PATH="/data/data/com.termux/files/usr/bin:$PATH"

BasePath="/data/local/chroot"
DisplayCmd="${LINA_ENTRY:+$LINA_ENTRY $LINA_ACTION}"
DisplayCmd="${DisplayCmd:-${0##*/}}"

usage() {
    cat << EOF
管理 chroot 环境的进程。

用法:
  $DisplayCmd    [Name] [模式=ps]    选择指定名称的环境进行操作
  $DisplayCmd    -h                  显示此帮助信息

参数:
  Name           chroot 环境的名称, 若省略则并在 ps 模式下遍历所有环境

模式:
  pids           列出环境中所有进程的 PID
  ka             终止环境中的所有进程 (静默模式)
  ps             列出一个表格, 包含环境中所有进程的信息
EOF
    exit "${1:-0}"
}

TargetName=""
Mode="ps"

if [[ -n "$1" ]]; then
    case "$1" in
        pids | ka | ps)
            Mode="$1"
            ;;
        -h | --help)
            usage 0
            ;;
        *)
            TargetName="$1"
            Mode="${2:-ps}"
            ;;
    esac
fi

if [[ -n "$TargetName" ]]; then
    SearchTarget="$BasePath/$TargetName"
    if [[ ! -d "$SearchTarget" ]]; then
        error "目录 '$SearchTarget' 不存在。"
        exit 1
    fi
else
    SearchTarget="$BasePath/*"
fi

get_pids() {
    find /proc/[0-9]*/root -lname "$SearchTarget" 2> /dev/null | while read -r _path; do
        _t="${_path#/proc/}"
        echo "${_t%/root}"
    done
}

show_ps() {
    printf "%-5s %-6s %-12s %s\n" "UID" "PID" "NAME" "COMMAND"

    _pids=$(get_pids)
    [[ -z "$_pids" ]] && return 0

    _GRAY=$(printf '\033[90m')
    _RESET=$(printf '\033[0m')

    echo "$_pids" | while read -r _pid; do
        [[ -z "$_pid" ]] && continue

        _uid=""
        _ppid=""
        if [[ -r "/proc/$_pid/status" ]]; then
            while read -r _line; do
                case "$_line" in
                    Uid:*)
                        # Uid: real effective saved_set fs
                        set -- ${_line#Uid:}
                        _uid="$1"
                        ;;
                    PPid:*)
                        set -- ${_line#PPid:}
                        _ppid="$1"
                        ;;
                esac
                [[ -n "$_uid" && -n "$_ppid" ]] && break
            done < "/proc/$_pid/status"
        fi

        if [[ -n "$TargetName" ]]; then
            _name="$TargetName"
        else
            if _link=$(readlink "/proc/$_pid/root" 2> /dev/null); then
                _name="${_link##*/}"
            else
                _name="?"
            fi
        fi

        _cmd=""
        if [[ -r "/proc/$_pid/cmdline" ]]; then
            _cmd=$(tr '\0' ' ' < "/proc/$_pid/cmdline")
        fi
        if [[ -z "$_cmd" && -r "/proc/$_pid/comm" ]]; then
            read -r _cmd < "/proc/$_pid/comm"
            _cmd="[$_cmd]"
        fi

        _line_str=$(printf "%-5s %-6s %-12s %s" "${_uid:-?}" "$_pid" "${_name:-?}" "${_cmd:-?}")

        if [[ "$_ppid" -ne 1 ]] 2> /dev/null; then
            printf "%s%s%s\n" "$_GRAY" "$_line_str" "$_RESET"
        else
            printf "%s\n" "$_line_str"
        fi
    done
}

do_kill() {
    _pids=$(get_pids)

    [[ -z "$_pids" ]] && return 0

    # 发送 SIGTERM
    for _pid in $_pids; do
        kill -15 "$_pid" 2> /dev/null
    done

    # 等待退出循环
    _timeout=50 # 5秒 (50 * 0.1s)
    _count=0

    while [ "$_count" -lt "$_timeout" ]; do
        _alive_count=0
        for _pid in $_pids; do
            if kill -0 "$_pid" 2> /dev/null; then
                _alive_count=$((_alive_count + 1))
            fi
        done

        [ "$_alive_count" -eq 0 ] && break

        sleep 0.1
        _count=$((_count + 1))
    done

    # 发送 SIGKILL 给剩余进程
    for _pid in $_pids; do
        if kill -0 "$_pid" 2> /dev/null; then
            kill -9 "$_pid" 2> /dev/null
        fi
    done
}

case "$Mode" in
    ps) show_ps ;;
    pids) get_pids ;;
    ka) do_kill ;;
    *) usage 1 ;;
esac

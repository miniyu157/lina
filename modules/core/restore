#!/system/bin/sh

# SPDX-License-Identifier: GPL-3.0-or-later
# Copyright (C) 2025 Yumeka <miniyu157@163.com>

# shellcheck shell=ksh

if [ "$(id -u)" -ne 0 ]; then
    current_script="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
    quoted_args=$(printf " %q" "$@")
    exec su -M -c "exec '$current_script'$quoted_args"
fi
ScriptDir="$(cd "$(dirname "$0")" && pwd)"

# 启用此段以使用 makepkg 风格输出
if [[ ! -f "$ScriptDir/lib/message.sh" ]]; then
    echo "错误: 未找到 $ScriptDir/lib/message.sh" >&2
    exit 1
fi
source "$ScriptDir/lib/message.sh"
QUIET=0
colorize

# 启用以下两行以使用 Termux 中的二进制程序和库
export LD_LIBRARY_PATH="/data/data/com.termux/files/usr/lib"
PATH="/data/data/com.termux/files/usr/bin:$PATH"

BasePath="/data/local/chroot"
DisplayCmd="${LINA_ENTRY:+$LINA_ENTRY $LINA_ACTION}"
DisplayCmd="${DisplayCmd:-${0##*/}}"

usage() {
    cat << EOF
从归档中恢复 chroot 根文件系统。

用法: $DisplayCmd <Name> <BackupDir>

参数:
  Name         新的 chroot 根文件系统的文件夹名称
  BackupDir    归档文件存放的目标目录
EOF
    exit 1
}

Name="$1"
BackupDir="$2"
[[ -z $Name ]] && {
    error "未提供名称。"
    usage
}
[[ -z $BackupDir ]] && {
    error "未提供备份目录。"
    usage
}

RootFs="$BasePath/$Name"
[[ -d $RootFs ]] && {
    error "目录 '$RootFs' 已存在。"
    exit 1
}

msg "扫描备份文件..."
cd "$BackupDir" || exit 1
set -- *.tar.zst
if [ "$#" -eq 0 ] || [ ! -f "$1" ]; then
    error "未找到 .tar.zst 备份文件。"
    exit 1
fi
i=1
for file in "$@"; do
    plain "[%d] %s" "$i" "$file"
    i=$((i + 1))
done

ask "选择一个归档文件: "
read -r choice < /dev/tty
if [ -z "$choice" ] || [ "$choice" -lt 1 ] || [ "$choice" -gt "$#" ] 2> /dev/null; then
    error "无效的选择: %s" "$choice"
    exit 1
fi

shift "$((choice - 1))"
SelectedFile="$1"

mkdir -p "$RootFs"

msg2 "恢复: %s -> %s" "$SelectedFile" "$RootFs"

{ if command -v pv > /dev/null; then pv "$SelectedFile"; else cat "$SelectedFile"; fi; } |
    zstd -d |
    tar -xp -C "$RootFs" --strip-components=1

if [ -d "$RootFs" ]; then
    msg "恢复完成。"
else
    error "目标目录未创建。"
fi

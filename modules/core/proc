#!/system/bin/sh

# SPDX-License-Identifier: GPL-3.0-or-later
# Copyright (C) 2025 Yumeka <miniyu157@163.com>

# shellcheck shell=ksh
# shellcheck disable=SC2086

(($(id -u) != 0)) && exec su --mount-master -c "$(printf "%q " "$(readlink -f "$0")" "$@")"
BasePath="/data/local/chroot"
DisplayCmd="${LINA_ENTRY:+$LINA_ENTRY $LINA_ACTION}"
DisplayCmd="${DisplayCmd:-${0##*/}}"

usage() {
    cat << EOF
管理或查看 chroot 环境的进程。

用法:
  $DisplayCmd    [Name] [模式=ps]    选择指定名称的环境进行操作
  $DisplayCmd    -h --help           显示此帮助信息

参数:
  Name           chroot 环境的名称, 若省略则并在 ps 模式下遍历所有环境

模式:
  pids           列出环境中所有进程的 PID
  ka             终止环境中的所有进程
  ps             列出一个表格, 包含环境中所有进程的信息
EOF
    exit "${1:-0}"
}

TargetName=""
Mode="ps"

if [[ -n $1 ]]; then
    case "$1" in
        pids | ka | ps)
            Mode="$1"
            ;;
        -h | --help)
            usage 0
            ;;
        *)
            TargetName="$1"
            Mode="${2:-ps}"
            ;;
    esac
fi

if [[ -n $TargetName ]]; then
    SearchTarget="$BasePath/$TargetName"
    if [[ ! -d $SearchTarget ]]; then
        exit 1
    fi
else
    SearchTarget="$BasePath/*"
fi

get_pids() {
    local _path _t

    find /proc/[0-9]*/root -lname "$SearchTarget" 2> /dev/null | while read -r _path; do
        _t="${_path#/proc/}"
        echo "${_t%/root}"
    done
}

show_ps() {
    local _pids _GRAY _RESET _pid _uid _ppid _line _name _link _cmd _line_str

    printf "%-5s %-6s %-12s %s\n" "UID" "PID" "NAME" "COMMAND"

    _pids=$(get_pids)
    [[ -z $_pids ]] && return 0

    _GRAY=$(printf '\033[90m')
    _RESET=$(printf '\033[0m')

    echo "$_pids" | while read -r _pid; do
        [[ -z $_pid ]] && continue

        _uid=""
        _ppid=""
        if [[ -r "/proc/$_pid/status" ]]; then
            while read -r _line; do
                case "$_line" in
                    Uid:*)
                        # Uid: real effective saved_set fs
                        set -- ${_line#Uid:}
                        _uid="$1"
                        ;;
                    PPid:*)
                        set -- ${_line#PPid:}
                        _ppid="$1"
                        ;;
                esac
                [[ -n $_uid && -n $_ppid ]] && break
            done < "/proc/$_pid/status"
        fi

        if [[ -n $TargetName ]]; then
            _name="$TargetName"
        else
            if _link=$(readlink "/proc/$_pid/root" 2> /dev/null); then
                _name="${_link##*/}"
            else
                _name="?"
            fi
        fi

        _cmd=""
        if [[ -r "/proc/$_pid/cmdline" ]]; then
            _cmd=$(tr '\0' ' ' < "/proc/$_pid/cmdline")
        fi
        if [[ -z $_cmd && -r "/proc/$_pid/comm" ]]; then
            read -r _cmd < "/proc/$_pid/comm"
            _cmd="[$_cmd]"
        fi

        _line_str=$(printf "%-5s %-6s %-12s %s" "${_uid:-?}" "$_pid" "${_name:-?}" "${_cmd:-?}")

        if [[ $_ppid -ne 1 ]] 2> /dev/null; then
            printf "%s%s%s\n" "$_GRAY" "$_line_str" "$_RESET"
        else
            printf "%s\n" "$_line_str"
        fi
    done
}

do_kill() {
    local _pids _pid _timeout _count _alive_count

    _pids=$(get_pids)

    [[ -z $_pids ]] && return 0

    # 发送 SIGTERM
    for _pid in $_pids; do
        kill -15 "$_pid" 2> /dev/null
    done

    # 等待退出循环
    _timeout=50 # 5秒 (50 * 0.1s)
    _count=0

    while ((_count < _timeout)); do
        _alive_count=0
        for _pid in $_pids; do
            if kill -0 "$_pid" 2> /dev/null; then
                ((_alive_count++))
            fi
        done

        ((_alive_count == 0)) && break

        sleep 0.1
        ((_count++))
    done

    # 发送 SIGKILL 给剩余进程
    for _pid in $_pids; do
        if kill -0 "$_pid" 2> /dev/null; then
            kill -9 "$_pid" 2> /dev/null
        fi
    done
}

case "$Mode" in
    ps) show_ps ;;
    pids) get_pids ;;
    ka) do_kill ;;
    *) usage 1 ;;
esac

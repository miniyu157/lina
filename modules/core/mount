#!/system/bin/sh

# SPDX-License-Identifier: GPL-3.0-or-later
# Copyright (C) 2025 Yumeka <miniyu157@163.com>

# shellcheck shell=ksh

if (($(id -u) != 0)); then
    current_script="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
    quoted_args=$(printf " %q" "$@")
    exec su -M -c "exec '$current_script'$quoted_args"
fi
ScriptDir="$(cd "$(dirname "$0")" && pwd)"

# 启用此段以使用 makepkg 风格输出
if [[ ! -f "$ScriptDir/lib/message.sh" ]]; then
    echo "错误: 未找到 $ScriptDir/lib/message.sh" >&2
    exit 1
fi
source "$ScriptDir/lib/message.sh"
QUIET=0
colorize

# 启用以下两行以使用 Termux 中的二进制程序和库
#export LD_LIBRARY_PATH="/data/data/com.termux/files/usr/lib"
#PATH="/data/data/com.termux/files/usr/bin:$PATH"

BasePath="/data/local/chroot"
DisplayCmd="${LINA_ENTRY:+$LINA_ENTRY $LINA_ACTION}"
DisplayCmd="${DisplayCmd:-${0##*/}}"

usage() {
    cat << EOF
挂载 chroot 文件系统。

用法: $DisplayCmd <Name>

参数:
  Name    chroot 环境的名称
EOF
    exit 1
}

Name="$1"
[[ -z $Name ]] && {
    error "未提供名称。"
    usage 1
}
RootFs="$BasePath/$Name"
[[ -d $RootFs ]] || {
    error "目录 '$RootFs' 不存在。"
    exit 1
}

try_mount() {
    local src="$1" tgt="$2"
    shift 2

    if $ScriptDir/is-mounted "$src" "$tgt"; then
        msg2y "跳过: %s" "$tgt"
    else
        if mount "$@" "$src" "$tgt" 2> /dev/null; then
            msg2g "成功: %s" "$tgt"
        else
            msg2err "失败: %s" "$tgt"
        fi
    fi
}

# /data
if mount -o remount,dev,suid /data; then
    msg2g "成功: remount /data (dev,suid)"
else
    msg2err "失败: remount /data (dev,suid)"
fi

# /tmp
TERMUX_TMP="/data/data/com.termux/files/usr/tmp"
CHROOT_TMP="$RootFs/tmp"
mkdir -p "$TERMUX_TMP"
chmod 1777 "$TERMUX_TMP"
mkdir -p "$CHROOT_TMP"
try_mount "$TERMUX_TMP" "$CHROOT_TMP" --bind

# /dev /dev/pts /dev/shm /proc /sys /sdcard
try_mount /dev "$RootFs/dev" --bind
mkdir -p "$RootFs/dev/pts" "$RootFs/dev/shm" \
    "$RootFs/proc" "$RootFs/sys" "$RootFs/sdcard"
try_mount devpts "$RootFs/dev/pts" -t devpts
try_mount tmpfs "$RootFs/dev/shm" -t tmpfs -o mode=1777,size=512m
try_mount proc "$RootFs/proc" -t proc
try_mount sysfs "$RootFs/sys" -t sysfs
try_mount /sdcard "$RootFs/sdcard" --bind
